<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>example.com</title>
	</head>
	<body>
		<a class="github-corner" target="_blank" href="https://github.com/jimmywarting/StreamSaver.js">
			<svg width="100" height="100" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;">
				<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
				<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
				<text class="github-corner-text" text-anchor="middle" x="175" y="25" transform="rotate(45)" font-size="30" font-weight="bold">Fork me on Github</text>
			</svg>
			<style>.github-corner:hover .octo-arm{animation: octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%, 100%{transform: rotate(0)}20%, 60%{transform: rotate(-25deg)}40%, 80%{transform: rotate(10deg)}}@media (max-width: 500px){.github-corner:hover .octo-arm{animation: none}.github-corner .octo-arm{animation: octocat-wave 560ms ease-in-out}.github-corner-text{display: none;}.github-corner svg{height: 50px; width: 50px;}}</style>
		</a>

		<h1>Example of saving a stream directly to the filesystem</h1>
		<form id="$form">
			<h3>What would you like to save?</h3>
			<label><input name="kind" value="text" type="radio" checked>Plain text (Save as you type)</label><br>
			<label><input name="kind" value="video" type="radio">Video stream</label><br>
			<label><input name="kind" value="audio" type="radio">Audio stream</label><br>
			<!-- disabled until now, haven't had the time to write any demo using fetch -->
			<label><input name="kind" value="fetch" type="radio">Fetch stream</label>
			 - kind of cheesy, since you can use fetchEvent to add
			 Content-Disposition header (but requires service worker + ssl)<br>
			<label><input name="kind" value="screen" type="radio">Screen stream</label>
			- requires chromes <a href="https://goo.gl/5La0Iz">Screen Capturing</a> extension<br><br>
			<label>What should the name of the file be?<br>
				<input name="$filename" required value="sample.txt">
			</label>
			<input type="submit" value="Start">
		</form>
		<div id="$writer" hidden>
			<button id="$a">Write some aaa's</button>
			<button id="$b">Write some bbb's</button>
			<button id="$c">Write some ccc's</button>
		</div>
		<button id="$close" hidden>close stream</button>
		<script src="https://rawgit.com/jimmywarting/browser-su/master/build/permissions.js"></script>
		<script src="https://wzrd.in/standalone/web-streams-polyfill@latest"></script>
		<script src="StreamSaver.js"></script>
		<script>
			$form.onsubmit = event => {
				event.preventDefault()

				let
				kind = $form.querySelector(':checked').value,
				filename = $form.$filename.value,
				permission,
				url = "https://d8d913s460fub.cloudfront.net/videoserver/cat-test-video-320x240.mp4",
				myFile = fs.createWriteStream(filename)

				$form.remove()
				$close.hidden = false
				$close.onclick = event => myFile.close()

				switch (kind) {
					case "text":
						$writer.hidden = false
						let encoder = new TextEncoder

						let data = "a".repeat(1024)
						let uint8array = encoder.encode(data + "\n\n")
						myFile.write(uint8array) // Write some data to triger saving

						$a.onclick = $b.onclick = $c.onclick = event => {
							let data = event.target.id[1].repeat(1024)
							let uint8array = encoder.encode(data + "\n\n")
							myFile.write(uint8array)
						}
					break; case "video":
						permission = {name: 'userMedia', video: true}
					break; case "audio":
						permission = {name: 'userMedia', audio: true}
					break; case "screen":
						permission = {name: 'screen'}
					break;
					case "file":
					case "blob":

						var blob = new Blob([
							"a".repeat(1024),
							"b".repeat(1024),
							"c".repeat(1024)
						])

						let stream = fs.createBlobReader(blob)
						stream.pipeTo(myFile)

						// This is rather quite simple with fetch
						// cuz you can retrive an actual stream with it
						// Create a object url that you can request
						// then just fall into next "fetch case"
						url = URL.createObjectURL(blobOrFile)

						// If you would like to see an other method
						// that dosn't use ajax but uses FileReader instead
						// look in the ./util.js
					case "fetch":
						// Here we could just simply open the link and then let
						// the SW add Content-Disposition header to that request.
						fetch(url).then(res => {
							// https://jakearchibald.com/2016/streams-ftw/
							// The body is a stream :)
							console.log(res.body)
							let reader = res.body.getReader()
							let pump = () => {
								return reader.read().then(({ value, done }) => {
									if (done) {
										myFile.close()
										return
									}
									myFile.write(value)
									return pump()
								})
							}
							pump()
						})
					break;
				}

				permission && su.request(permission).then(stream => {
					let fr = new FileReader
					let mediaRecorder = new MediaRecorder(stream)
					let chunks = Promise.resolve()

					mediaRecorder.start()
					$close.onclick = event => {
						stopStream(stream)
						mediaRecorder.stop()
						setTimeout(()=>{
							chunks.then(evt => {
								myFile.close()
							})
						}, 1000)
					}
					mediaRecorder.ondataavailable = evt => {
						let blob = evt.data

						chunks = chunks.then(() => new Promise(resolve => {
							fr.onload = () => {
								// Should we let the serviceWorker be able to accept
								// anything other then uint8array? ReadableStream don't seems
								// so happy with anything else... but could load of some work
								// of the main thread +1
								let uint8array = new Uint8Array(fr.result)
								myFile.write(uint8array)
								resolve()
							}
							fr.readAsArrayBuffer(blob)
						}))
					}

				})
			}


			function stopStream (stream) {
				let tracks = [
					...stream.getAudioTracks(),
					...stream.getVideoTracks()
				]

				for(let track of tracks)
					track.stop()
			}
		</script>
	</body>
</html>
