<script>
/*
 * This is only meant to signal the opener's messageChannel to
 * the service worker
 * The service worker is capitable of intercepting all request and fork theire
 * own "fake" response - wish we are going to craft
 * when the worker then recives a stream then the worker will tell this middle
 * man to open up a link that will start the download
 */

// Service worker only works on https (and localhost)
var host = "YOURDOMAIN.github.io"
if (window.location.host == host && window.location.protocol != "https:")
    window.location.protocol = "https:"

function pair(message, port) {
	// This sends the message data as well as transferring messageChannel.port2 to the service worker.
    // The service worker can then use the transferred port to reply via postMessage(), which
    // will in turn trigger the onmessage handler on messageChannel.port1.
    // See https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage
    navigator.serviceWorker.controller.postMessage(message, [port])

	// serviceWorker is telling us to open up a uniq link that will start
	// saving the file to the disk with the help of Content-Disposition
	navigator.serviceWorker.onmessage = event => {
        let link = document.createElement('a')
        let click = new MouseEvent('click')

        link.href = event.data.href
		link.dispatchEvent(click)
	}
}

// message event is the first thing we need to setup a listner for
// don't want the opener to do a random timeout - instead they can listen for
// the ready event
window.onmessage = event => {
	console.log(event.origin)


    if(!event.ports || !event.ports.length) {
        // It's important to have a messageChannel, don't want to interfair
        // with other simultainus downloads

        throw new TypeError("Mehhh! You didn't add send a messageChannel")
    }

    // Register the worker, then send the share the channel to the worker
    // So they can talk directly, so we don't have to be the middle man
        // Register the worker, then send the share the channel to the worker
    // So they can talk directly, so we don't have to be the middle man
    navigator.serviceWorker.getRegistration('./').then(sw => sw
		? pair(event.data, event.ports[0])
		: navigator.serviceWorker.register('sw.js', {scope: './'})
			.then(() => navigator.serviceWorker.ready)
			.then(() => {
				// navigator.serviceWorker.controller is frozzen to null and don't change
				iframe = document.createElement('iframe')
				iframe.src = location.href
				document.body.appendChild(iframe)
				iframe.onload = () => {
					controller = iframe.contentWindow.navigator.serviceWorker.controller
					pair(event.data, event.ports[0])
				}
				// iframe.remove() could work, haven't tested
			})
	, err => console.log(err))

}
</script>
